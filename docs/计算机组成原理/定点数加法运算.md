

### 移位运算

#### 算术移位

原码的算术移位: 符号位不变，数值位进行移位。 向右移位相当于 / 2, 高位补0地位舍弃，如果舍弃的位!=0, 则会精度丢失; 左移相当于 \*2的效果，地位补领，高位舍弃，如果舍弃的位!=0，则会造成严重的误差。

#### 逻辑移位

逻辑左移: 低位补0高位舍弃
逻辑右移: 高位补0地位舍弃

可以看成是对”无符号数“的算术移位

-----------------------
*逻辑移位应用举例*

<img src="../../images/QQ截图20201203112946.png">


#### 循环移位

- 不带进位: 用移除的位补上空缺，循环左移, 最高位的位补上最低位的位，循环右移，最低位的位补上最高位的位
- 带进位位: 移除的位放到进位位，进位位的元素补上空缺

<img src="../../images/QQ截图20201203141619.png">

-------------------
*循环移位应用*

字符的大小端存储转换，如汉字的大小端存储的转换，循环移位一个字节，8位，就能实现高低字节的调换。


### 注意

由于原/反补码位数有限，因此某些时候算术移位不能精确等效乘法，除法

### 加减运算

对于补码来说，无论加法还是减法，最后都会转变成加法，由加法器实现运算，符号位也参与运算。

设机器字长为8位（含一位符号位）, A=15, B=-24, 求[A+B]补和[A-B]补

```
				  原码           补码
A = +1111    ->  00001111    -> 00001111
B = -11000   ->  10011000    -> 11101000
-B = +11000  ->  00011000    -> 00011000

[A+B]补 = 00001111 + 11101000 = 11110111
								原码 10001001  -9

[A-B]补 = 00001111 + 00011000 = 00100111
 								原码 00100111   39
```
### 溢出
```
C = 124  求 [A+C]补
	
[A+C]补 = 00001111 + 01111100 = 10001011   真值 -117 溢出
```

因为 8位的补码的可表示范围为[-128, 2^8-1], 所以上述A+C 溢出了

### 判断溢出

<img src="../../images/QQ截图20201204105614.png">

#### 1. 采用一位符号位，根据符号位判断

<img src="../../images/QQ截图20201204110621.png">

#### 2. 采用一位符号位，根据进位位情况判断

||符号位的进位 Cs|最高位的进位C1|
|------|-------|--------|
上溢| 0 | 1
下溢| 1 | 0
即Cs和C1不同时有溢出||

#### 3. 采用双符号位

正数符号位00，负数符号位11

```
[A+C]补 = 00,0001111 + 00,1111100 = 01,0001011 上溢
[B-C]补 = 11,1101000 + 11,0000100 = 10,1101100 下溢
```

符号位的第一位为运算结果正确的符号位，符号位的第二位是运算实际的运算结果符号

记两个符号位为S1S2, 则V = S1 ^ S2, 若V=0，表示无溢出; 若V=1，表示有溢出

**实际存储时只存储一个符号位，运算时会复制一个符号位**

---------
双符号位的补码又称: 模4补码
单符号位的补码又称: 模2补码

### 溢出避免

#### 符号扩展

段数据->长数据.   int -> long 

多出来的怎么填补？ 

<img src="../../images/QQ截图20201204113512.png">







<img src="../../images/微信截图_20200811160913.png">

<img src="../../images/微信截图_20200811160955.png">

<img src="../../images/微信截图_20200811161142.png">

### 面试题27: 二叉树的镜像
<img src="../../images/微信截图_20200811161231.png">

<img src="../../images/微信截图_20200813194022.png">

```c++
struct Node
{
    int value;
    Node* left = nullptr;
    Node* right = nullptr;
};

void exchangeChild(Node* pNode);

void treeMirror(Node* pRoot)
{
    if (pRoot == nullptr)
        return;

    exchangeChild(pRoot);
}

void exchangeChild(Node* pNode)
{
    if (pNode == nullptr)
        return;

    Node* left = pNode->left;
    Node* right = pNode->right;

    pNode->left = right;
    pNode->right = left;
    exchangeChild(pNode->left);
    exchangeChild(pNode->right);
}
```

完整代码： <a href="https://github.com/yiouejv/blog/blob/master/docs/%E5%89%91%E6%8C%87offer/codes/treeMirror.cpp">树的镜像</a>    

<img src="../../images/微信截图_20200813200559.png">

### 面试题28: 对称的二叉树

<img src="../../images/微信截图_20200817142013.png">

<img src="../../images/微信截图_20200817142043.png">

```c++
bool isSymmetric(Node* pRoot1, Node* pRoot2)

bool isSymmetric(Node* pRoot)
{
    return isSymmetric(pRoot->pLeft, pRoot->pRight);
}

bool isSymmetric(Node* pRoot1, Node* pRoot2)
{
    if (pRoot1 == nullptr || pRoot2 == nullptr)
        return false;

    if (pRoot1->value != pRoot2->value)
        return false;

    if (pRoot1 == nullptr && pRoot2 == nullptr)
        return true;

    return isSymmetric(pRoot1->pLeft, pRoot2->pRight)
        && isSymmetric(pRoot1->pRight, pRoot2->pLeft);
}
```

完整代码： <a href="https://github.com/yiouejv/blog/blob/master/docs/%E5%89%91%E6%8C%87offer/codes/symmetricTree.cpp">对称的二叉树</a>    

<img src="../../images/微信截图_20200817142319.png">


### 面试题29: 顺时针打印矩阵

<img src="../../images/微信截图_20200817143341.png">

### 面试题30: 包含min函数的栈

<img src="../../images/微信截图_20200817145754.png">

<img src="../../images/微信截图_20200817145817.png">

<img src="../../images/微信截图_20200817145833.png">

<img src="../../images/微信截图_20200817145858.png">

<img src="../../images/微信截图_20200817145937.png">


### 面试题31: 栈的压入，弹出序列

<img src="../../images/微信截图_20200817192358.png">

<img src="../../images/微信截图_20200817192454.png">

<img src="../../images/微信截图_20200817192513.png">

```c++
bool isPopOrder(vector<int>& pushVector, vector<int>& popVector)
{
    if (pushVector.size() <= 0 || popVector.size() <= 0)
        return false;

    stack<int> stackTemp;
    unsigned int pushVectorIndex = 0;
    unsigned int popVectorIndex = 0;

    stackTemp.push(pushVector[pushVectorIndex++]);

    while (popVectorIndex < popVector.size())
    {
        while (stackTemp.top() != popVector[popVectorIndex])
        {
            if (pushVectorIndex >= pushVector.size())
                break;
            stackTemp.push(pushVector[pushVectorIndex++]);
        }

        if (stackTemp.top() != popVector[popVectorIndex])
            break;

        stackTemp.pop();
        popVectorIndex++;
    }
    if (stackTemp.empty())
        return true;
    return false;
}
```

完整代码：  <a href="https://github.com/yiouejv/blog/blob/master/docs/%E5%89%91%E6%8C%87offer/codes/isPopOrder.cpp">栈的压入，弹出序列</a>     

<img src="../../images/微信截图_20200817194914.png">










用lua工作有一段时间了，正好最近工作有点时间，再把lua参考手册过一遍，记录记录

<a href="lua5.3参考手册">https://cloudwu.github.io/lua53doc/manual.html#pdf-table.concat</a>

### number

number 类型可以表示为整数和浮点数，程序员大多数情况可以忽略整数和浮点数的差异(lua内)，因为lua内部会自动根据使用场景进行转换。

- 位操作: 总是将浮点数转换成整数

	<img src="../../images/QQ截图20200924143416.png">

- 乘方和浮点除法总是将整数转换成浮点数。

	<img src="../../images/QQ截图20200924143645.png">

- 数学操作若针对混合操作数 （整数和浮点数）将把整数转换为浮点数

当把一个整数转换为浮点数时， 若整数值恰好可以表示为一个浮点数，那就取那个浮点数。 否则，转换会取最接近的较大值或较小值来表示这个数。 这种转换是不会失败的。

将浮点数转为整数的过程会检查 浮点数能否被准确的表达为一个整数 （即，浮点数是一个整数值且在整数可以表达的区间）。 如果可以，结果就是那个数，否则转换失败。

--------------------------------------

### table

table 是一个关联数组， 也就是说，这个数组不仅仅以数字做索引，除了 nil 和 NaN 之外的所有 Lua 值 都可以做索引。

<img src="../../images/QQ截图20200924145337.png">

表是 Lua 中唯一的数据结构， 它可被用于表示普通数组、序列、符号表、集合、记录、图、树等等。 对于记录，Lua 使用域名作为索引。 语言提供了 a.name 这样的语法糖来替代 a["name"] 这种写法以方便记录这种结构的使用。

我们使用 *序列* 这个术语来表示一个用 {1..n} 的正整数集做索引的表。 这里的非负整数 n 被称为该序列的长度,  表 t 的长度只在表是一个 *序列* 时有定义,  序列指表的正数键集等于 {1..n} ， 其中 n 是一个非负整数。 在这种情况下，n 是表的长度。 
注意这样的表
```lua
{10, 20, nil, 40}
```
不是一个序列，因为它有键 4 却没有键 3。 （因此，该表的正整数键集不等于 {1..n} 集合，故而就不存在 n。） 

索引一张表的原则遵循语言中的直接比较规则。 当且仅当 i 与 j直接比较相等时 （即不通过元方法的比较）， 表达式 a[i] 与 a[j] 表示了表中相同的元素。 特别指出：一个可以完全表示为整数的浮点数和对应的整数相等 （例如：1.0 == 1）。 为了消除歧义，当一个可以完全表示为整数的浮点数做为键值时， 都会被转换为对应的整数储存。 例如，当你写 a[2.0] = true 时， 实际被插入表中的键是整数 2 。 

### \_ENV \_G

lua语言把所有的代码都当作匿名函数处理，例如

```lua
local z = 10
x = y + 10
```

实际上会被编译为

```lua
local _ENV = smoe value (也就是预定义上值，假设该值存在)
return function (...)
    local z = 10
    _ENV.x = _ENV.y + z
end
```

<span style="color: red;">_ENV不是全局环境，它指向的是当前环境，而Lua又确保每个chunk（可以是一句代码，函数体，do ...end之间的内容等）都以_ENV开头，所以每个chunk中都可以拥有自己独立的环境。</span>
在每个环境中对非局部a的所有访问都转换为_ENV.a。这种方式更安全，并且更加灵活，因为可以通过创建局部_ENV变量来为单个代码块的创建单独的环境，从而降低块与块之间的耦合度。


lua语言在编译运行时首先会创建一个默认环境（也称为“全局环境”，_G表）并将其存储在注册表中。 <span style="color: red;">除非您将自定义环境（也就是自定义的_ENV）传递给load或loadfile，否则此默认环境将用作所有块的_ENV.</span>  lua_pushglobaltable还直接从注册表中检索此全局环境，因此所有C模块都会自动使用它来访问全局变量。并且，如果标准的C模块已加载，则此默认的“全局环境”具有一个名为_G的表字段，该表字段引用回全局环境。

简单的说就是首先lua会有一个_G表,若没有人为的设置，则这个_G表直接就被用作的_ENV（而且所有的块都将以此_ENV开头），然后_ENV的里存储着一个键值对_G = _G（全局环境表）。任何对该环境的更改也将直接作用到_G上，因为这两个初始时引用的同一个表，类似下面

```lua
print(_G) -- table: 0000021DC4BE6700
print(_ENV._G) -- table: 0000021DC4BE6700
```

当然我们可以创建自己的环境，并继承全局环境，但不改变全局环境

```lua
b = 25
_G = setmetatable(_G,{__newindex = function() print("can change this table") end})
a = 13 
local _ENV = setmetatable({},{__index = _G})
c = 14
print(a,b,c)
print(_G.a,_G.b,_G.c)
```

```
can change this table
nil	25	14
nil	25	nil
```

> load (chunk [, chunkname [, mode [, env]]])
> 加载一个代码块。

> 如果 chunk 是一个字符串，代码块指这个字符串。 如果 chunk 是一个函数， load 不断地调用它获取代码块的片断。 每次对 chunk 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、nil、或是不返回值时，都表示代码块结束。

> 如果没有语法错误， 则以函数形式返回编译好的代码块； 否则，返回 nil 加上错误消息。

> 如果结果函数有上值， env 被设为第一个上值。 若不提供此参数，将全局环境替代它。 所有其它上值初始化为 nil。 （当你加载主代码块时候，结果函数一定有且仅有一个上值 _ENV 。 然而，如果你加载一个用函数创建出来的二进制代码块时，所有的上值都是新创建出来的。 也就是说它们不会和别的任何函数共享。

> chunkname 在错误消息和调试消息中，用于代码块的名字。 如果不提供此参数，它默认为字符串chunk 。 chunk 不是字符串时，则为 "=(load)" 。

> 字符串 mode 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 "b" （只能是二进制代码块）， "t" （只能是文本代码块）， 或 "bt" （可以是二进制也可以是文本）。 默认值为 "bt"。

> Lua 不会对二进制代码块做健壮性检查。 恶意构造一个二进制块有可能把解释器弄崩溃。


```lua
local _env = {print=_ENV.print, a=15}
local a = 12
local str = "print(a)"
load(str, "test", "t", _env)()
```

首先我们自定义了_ENV环境，并将其传给了load函数，所以load加载运行时的环境为我们自定义的_ENV环境，所以此时结果为15.

### 元表

lua 中只能改变表类型值的元表, 若想改变非表类型的值的元表, 需使用C PAI

元表决定了一个对象在数学运算、位运算、比较、连接、 取长度、调用、索引时的行为。 元表还可以定义一个函数，当表对象或用户数据对象在垃圾回收时调用。


### 垃圾收集

Lua 采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。 Lua 运行了一个 垃圾收集器 来收集所有 死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。

Lua 实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： 垃圾收集器间歇率 和 垃圾收集器步进倍率。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示 1 ）。

垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。

垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的“两倍”速工作。

如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。

你可以通过在 C 中调用 lua_gc 或在 Lua 中调用 collectgarbage 来改变这俩数字。 这两个函数也可以用来直接控制收集器（例如停止它或重启它）。

> collectgarbage ([opt [, arg]])

> 这个函数是垃圾收集器的通用接口。 通过参数 opt 它提供了一组不同的功能：

- "collect": 做一次完整的垃圾收集循环。 这是默认选项。
- "stop": 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。
- "restart": 重启垃圾收集器的自动运行。
- "count": 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。
- "step": 单步运行垃圾收集器。 步长“大小”由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。
- "setpause": 将 arg 设为收集器的 间歇率 （参见 §2.5）。 返回 间歇率 的前一个值。
- "setstepmul": 将 arg 设为收集器的 步进倍率 （参见 §2.5）。 返回 步进倍率 的前一个值。
- "isrunning": 返回表示收集器是否在工作的布尔值 （即未被停止）。

#### 垃圾收集元方法

可以为表设定垃圾收集的元方法, 对于完全用户数据则需要使用 C API, *元表* 之前也说过了; 该元方法被称为终结器, 终结器可以配合 Lua 的垃圾收集器做一些额外的资源管理工作 （例如关闭文件、网络或数据库连接，或是释放一些你自己的内存）

要想让一个对象在收集过程中进入终结流程, 你必须标记它需要触发终结器; 当你为这个对象设置元表时, 若此刻这张元表中用一个以字符串"\_\_gc"为索引的域, 那么就标记了这个对象需要触发终结器; 

注意: 如果你给对象设置元表时,这个元表没有\_\_gc 域, 之后再给元表加上\_\_gc 域, 则标记失败; 一旦对象被标记, \_\_gc 域之后是可以修改的

```lua
-- 成功标记对象
local function test1( ... )
	local obj = setmetatable({}, {
		__gc = function()
			print('__gc 被调用, 可以做一些事情')
		end
	})

	obj.a = 1
	obj.b = 2
	print(obj.a)
	print(obj.b)
end

--[[ 输出

1
2
__gc 被调用, 可以做一些事情

]] 
```

```lua
-- 未能成功标记对象
local function test2( ... )
	local metatable = {}
	local obj = setmetatable({}, metatable)
	metatable.__gc = function()
		print('__gc 被调用, 可以做一些事情')
	end

	obj.a = 1
	obj.b = 2
	print(obj.a)
	print(obj.b)
end

--[[ 输出

1
2

]] 
```

```lua
-- 未能成功标记对象后修改__gc域
local function test3( ... )
	local metatable = {
		__gc = function()
				print('__gc 被调用, 可以做一些事情')
			end
	}
	local obj = setmetatable({}, metatable)
	metatable.__gc = function()
		print('__gc 被调用, 修改__gc域')
	end

	obj.a = 1
	obj.b = 2
	print(obj.a)
	print(obj.b)
end

--[[ 输出

1
2
__gc 被调用, 修改__gc域


]] 
```

当一个被标记的对象成为了垃圾后，垃圾收集器并不会立刻回收它。 取而代之的是，Lua 会将其置入一个链表。 在收集完成后，Lua 将遍历这个链表。 Lua 会检查每个链表中的对象的 \_\_gc 元方法：如果是一个函数，那么就以对象为唯一参数调用它； 否则直接忽略它。

在每次垃圾收集循环的最后阶段，本次循环中检测到需要被回收的对象，终结器的触发顺序将和标记循序相反，第一个调用的终结器为最后一个被标记的对象携带的那个; 每个终结器的运行可能发生在执行代码的任意时刻。

由于被回收的对象还需要被终结器使用， 该对象（以及仅能通过它访问到的其它对象）一定会被 Lua 复活。 通常，复活是短暂的，对象所属内存会在下一个垃圾收集循环释放。 然后，若终结器又将对象保存去一些全局的地方 （例如：放在一个全局变量里），这次复活就持续生效了。 此外，如果在终结器中对一个正进入终结流程的对象再次做一次标记让它触发终结器， 只要这个对象在下个循环中依旧不可达，它的终结函数还会再调用一次。 无论是哪种情况， 对象所属内存仅在垃圾收集循环中该对象不可达且 没有被标记成需要触发终结器才会被释放。

当你关闭一个状态机，Lua 将调用所有被标记了需要触发终结器对象的终结过程， 其次序为标记次序的逆序。 在这个过程中，任何终结器再次标记对象的行为都不会生效。

#### 弱表

弱表是一个表且拥有metatable元表，并在metatable中定义了__mode字段。

一张弱表可以有弱键或是弱值，也可以键值都是弱引用。 含有弱值的表允许收集器回收它的值，但会阻止收集器回收它的键。 若一张表的键值均为弱引用， 那么收集器可以回收其中的任意键和值。 任何情况下，只要键或值的任意一项被回收， 相关联的键值对都会从表中移除。 一张表的元表中的 \_\_mode 域控制着这张表的弱属性。 当 \_\_mode 域是一个包含字符 'k' 的字符串时，这张表的所有键皆为弱引用。 当 \_\_mode 域是一个包含字符 'v' 的字符串时，这张表的所有值皆为弱引用。

弱表中的引用是弱引用，弱引用不会导致对象引用计数变化。换言之，如果一个对象只有弱引用指向它，那么垃圾收集器会自动回收该对象所占用的内存空间。

下面是没有使用弱表的例子:

```lua
local tbl = {}

local key = {count = 100}
tbl[key] = 1

key = nil
print(tbl[key]) -- nil

-- 强制执行垃圾回收
collectgarbage("collect")

for k,v in pairs(tbl) do
    print(k, v, k.count)-- table: 00000000001a9b70   1   100
end
```

当把对象放入表中时就会产生一个引用，即使其他地方没有对表中的元素有任何引用，垃圾收集器也不会回收这些对象，你只能选择手动释放表元素或是将其常驻内存。

下面是使用了弱表:

```lua
local tbl = setmetatable({}, {__mode='k'})

local key = {count = 100}
tbl[key] = 1

key = nil
print(tbl[key]) -- nil

-- 强制执行垃圾回收
collectgarbage("collect")

for k,v in pairs(tbl) do
    print(k, v, k.count)
end
```

只输出一个nil，为`print(tbl[key]) -- nil` 输出，强制垃圾回收之后，key 表被回收，tbl表中的key:1 被移除，pairs 将遍历空表，则没有输出。

**应用案例**

使用“空间换时间”是一种通用的程序运行效率优化手段，例如对于一个普通的服务器，它接收到的请求中包含Lua代码，每当收到请求后都会调用Lua的`loadstring`函数来动态解析请求中的Lua代码，如果这种操作过于频繁，会直接导致服务器的执行效率下降。

要解决这个问题，可以将每次解析的结果缓存到一个table中，下次如果接收到相同的Lua代码则无需调用`loadstring`来动态解析，而是直接从table中获取并直接执行即可。这样，在有大量重复Lua代码的情况下，可极大地提高服务器的执行效率。反之，若有相当一部分的Lua代码只是出现一次，使用这种机制会导致大量的内存资源被占用而得不到有效的释放。在这种情况下，如果使用弱表，不仅仅可以在一定程序上提升程序的运行效率，内存资源也会得到有效的释放。

```lua
local result = {}
setmetatable( result, {__mode="v"} )

function mem_loadstring(str)
    local val = result[str]
    if val==nil then
        val = assert( loadstring( str ) )
        result[str] = val
    end
    return val
end
```